ARM GAS  /tmp/cc3y5xFn.s 			page 1


   1              		.cpu cortex-m0plus
   2              		.eabi_attribute 20, 1
   3              		.eabi_attribute 21, 1
   4              		.eabi_attribute 23, 3
   5              		.eabi_attribute 24, 1
   6              		.eabi_attribute 25, 1
   7              		.eabi_attribute 26, 1
   8              		.eabi_attribute 30, 1
   9              		.eabi_attribute 34, 0
  10              		.eabi_attribute 18, 4
  11              		.file	"main.c"
  12              		.text
  13              	.Ltext0:
  14              		.cfi_sections	.debug_frame
  15              		.section	.text.HW_GetBatteryLevel,"ax",%progbits
  16              		.align	1
  17              		.global	HW_GetBatteryLevel
  18              		.syntax unified
  19              		.code	16
  20              		.thumb_func
  21              		.fpu softvfp
  23              	HW_GetBatteryLevel:
  24              	.LFB230:
  25              		.file 1 "./Src/main.c"
   1:./Src/main.c  **** /*
   2:./Src/main.c  **** / _____)             _              | |
   3:./Src/main.c  **** ( (____  _____ ____ _| |_ _____  ____| |__
   4:./Src/main.c  **** \____ \| ___ |    (_   _) ___ |/ ___)  _ \
   5:./Src/main.c  **** _____) ) ____| | | || |_| ____( (___| | | |
   6:./Src/main.c  **** (______/|_____)_|_|_| \__)_____)\____)_| |_|
   7:./Src/main.c  ****    (C)2013 Semtech
   8:./Src/main.c  **** 
   9:./Src/main.c  **** Description: Generic lora driver implementation
  10:./Src/main.c  **** 
  11:./Src/main.c  **** License: Revised BSD License, see LICENSE.TXT file include in the project
  12:./Src/main.c  **** 
  13:./Src/main.c  **** Maintainer: Miguel Luis, Gregory Cristian and Wael Guibene
  14:./Src/main.c  **** */
  15:./Src/main.c  **** /******************************************************************************
  16:./Src/main.c  ****   * @file    main.c
  17:./Src/main.c  ****   * @author  MCD Application Team
  18:./Src/main.c  ****   * @version V1.1.2
  19:./Src/main.c  ****   * @date    08-September-2017
  20:./Src/main.c  ****   * @brief   this is the main!
  21:./Src/main.c  ****   ******************************************************************************
  22:./Src/main.c  ****   * @attention
  23:./Src/main.c  ****   *
  24:./Src/main.c  ****   * <h2><center>&copy; Copyright (c) 2017 STMicroelectronics International N.V. 
  25:./Src/main.c  ****   * All rights reserved.</center></h2>
  26:./Src/main.c  ****   *
  27:./Src/main.c  ****   * Redistribution and use in source and binary forms, with or without 
  28:./Src/main.c  ****   * modification, are permitted, provided that the following conditions are met:
  29:./Src/main.c  ****   *
  30:./Src/main.c  ****   * 1. Redistribution of source code must retain the above copyright notice, 
  31:./Src/main.c  ****   *    this list of conditions and the following disclaimer.
  32:./Src/main.c  ****   * 2. Redistributions in binary form must reproduce the above copyright notice,
  33:./Src/main.c  ****   *    this list of conditions and the following disclaimer in the documentation
ARM GAS  /tmp/cc3y5xFn.s 			page 2


  34:./Src/main.c  ****   *    and/or other materials provided with the distribution.
  35:./Src/main.c  ****   * 3. Neither the name of STMicroelectronics nor the names of other 
  36:./Src/main.c  ****   *    contributors to this software may be used to endorse or promote products 
  37:./Src/main.c  ****   *    derived from this software without specific written permission.
  38:./Src/main.c  ****   * 4. This software, including modifications and/or derivative works of this 
  39:./Src/main.c  ****   *    software, must execute solely and exclusively on microcontroller or
  40:./Src/main.c  ****   *    microprocessor devices manufactured by or for STMicroelectronics.
  41:./Src/main.c  ****   * 5. Redistribution and use of this software other than as permitted under 
  42:./Src/main.c  ****   *    this license is void and will automatically terminate your rights under 
  43:./Src/main.c  ****   *    this license. 
  44:./Src/main.c  ****   *
  45:./Src/main.c  ****   * THIS SOFTWARE IS PROVIDED BY STMICROELECTRONICS AND CONTRIBUTORS "AS IS" 
  46:./Src/main.c  ****   * AND ANY EXPRESS, IMPLIED OR STATUTORY WARRANTIES, INCLUDING, BUT NOT 
  47:./Src/main.c  ****   * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A 
  48:./Src/main.c  ****   * PARTICULAR PURPOSE AND NON-INFRINGEMENT OF THIRD PARTY INTELLECTUAL PROPERTY
  49:./Src/main.c  ****   * RIGHTS ARE DISCLAIMED TO THE FULLEST EXTENT PERMITTED BY LAW. IN NO EVENT 
  50:./Src/main.c  ****   * SHALL STMICROELECTRONICS OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  51:./Src/main.c  ****   * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
  52:./Src/main.c  ****   * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, 
  53:./Src/main.c  ****   * OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF 
  54:./Src/main.c  ****   * LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING 
  55:./Src/main.c  ****   * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
  56:./Src/main.c  ****   * EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
  57:./Src/main.c  ****   *
  58:./Src/main.c  ****   ******************************************************************************
  59:./Src/main.c  ****   */
  60:./Src/main.c  **** 
  61:./Src/main.c  **** /* Includes ------------------------------------------------------------------*/
  62:./Src/main.c  **** #include <hw_i2c.h>
  63:./Src/main.c  **** #include <stm32l0xx_ll_i2c.h>
  64:./Src/main.c  **** #include "stm32l0xx_ll_i2c.h"
  65:./Src/main.c  **** #include "hw.h"
  66:./Src/main.c  **** #include "low_power.h"
  67:./Src/main.c  **** #include "lora.h"
  68:./Src/main.c  **** //#include "bsp.h"
  69:./Src/main.c  **** #include "timeServer.h"
  70:./Src/main.c  **** #include "vcom.h"
  71:./Src/main.c  **** #include "voc_sensor.h"
  72:./Src/main.c  **** 
  73:./Src/main.c  **** /* Private typedef -----------------------------------------------------------*/
  74:./Src/main.c  **** /* Private define ------------------------------------------------------------*/
  75:./Src/main.c  **** 
  76:./Src/main.c  **** #define LPP_APP_PORT 99
  77:./Src/main.c  **** 
  78:./Src/main.c  **** /*!
  79:./Src/main.c  ****  * Defines the application data transmission duty cycle. 5s, value in [ms].
  80:./Src/main.c  ****  */
  81:./Src/main.c  **** #define APP_TX_DUTYCYCLE                            10000
  82:./Src/main.c  **** /*!
  83:./Src/main.c  ****  * LoRaWAN Adaptive Data Rate
  84:./Src/main.c  ****  * @note Please note that when ADR is enabled the end-device should be static
  85:./Src/main.c  ****  */
  86:./Src/main.c  **** #define LORAWAN_ADR_ON                              1
  87:./Src/main.c  **** /*!
  88:./Src/main.c  ****  * LoRaWAN confirmed messages
  89:./Src/main.c  ****  */
  90:./Src/main.c  **** #define LORAWAN_CONFIRMED_MSG                    DISABLE
ARM GAS  /tmp/cc3y5xFn.s 			page 3


  91:./Src/main.c  **** /*!
  92:./Src/main.c  ****  * LoRaWAN application port
  93:./Src/main.c  ****  * @note do not use 224. It is reserved for certification
  94:./Src/main.c  ****  */
  95:./Src/main.c  **** #define LORAWAN_APP_PORT                            42
  96:./Src/main.c  **** //2
  97:./Src/main.c  **** /*!
  98:./Src/main.c  ****  * Number of trials for the join request.
  99:./Src/main.c  ****  */
 100:./Src/main.c  **** #define JOINREQ_NBTRIALS                            3
 101:./Src/main.c  **** 
 102:./Src/main.c  **** /* Private macro -------------------------------------------------------------*/
 103:./Src/main.c  **** /* Private function prototypes -----------------------------------------------*/
 104:./Src/main.c  **** 
 105:./Src/main.c  **** /* call back when LoRa will transmit a frame*/
 106:./Src/main.c  **** static void LoraTxData(lora_AppData_t *AppData, FunctionalState *IsTxConfirmed);
 107:./Src/main.c  **** 
 108:./Src/main.c  **** /* call back when LoRa has received a frame*/
 109:./Src/main.c  **** static void LoraRxData(lora_AppData_t *AppData);
 110:./Src/main.c  **** 
 111:./Src/main.c  **** uint8_t HW_GetBatteryLevel(void) {
  26              		.loc 1 111 0
  27              		.cfi_startproc
  28              		@ args = 0, pretend = 0, frame = 0
  29              		@ frame_needed = 0, uses_anonymous_args = 0
  30              		@ link register save eliminated.
 112:./Src/main.c  **** 	return 254;
 113:./Src/main.c  **** }
  31              		.loc 1 113 0
  32 0000 FE20     		movs	r0, #254
  33              		@ sp needed
  34 0002 7047     		bx	lr
  35              		.cfi_endproc
  36              	.LFE230:
  38              		.section	.text.main,"ax",%progbits
  39              		.align	1
  40              		.global	main
  41              		.syntax unified
  42              		.code	16
  43              		.thumb_func
  44              		.fpu softvfp
  46              	main:
  47              	.LFB231:
 114:./Src/main.c  **** 
 115:./Src/main.c  **** /* Private variables ---------------------------------------------------------*/
 116:./Src/main.c  **** /* load call backs*/
 117:./Src/main.c  **** static LoRaMainCallback_t LoRaMainCallbacks = {HW_GetBatteryLevel,
 118:./Src/main.c  ****                                                HW_GetUniqueId,
 119:./Src/main.c  ****                                                HW_GetRandomSeed,
 120:./Src/main.c  ****                                                LoraTxData,
 121:./Src/main.c  ****                                                LoraRxData};
 122:./Src/main.c  **** 
 123:./Src/main.c  **** 
 124:./Src/main.c  **** #ifdef USE_B_L072Z_LRWAN1
 125:./Src/main.c  **** /*!
 126:./Src/main.c  ****  * Timer to handle the application Tx Led to toggle
 127:./Src/main.c  ****  */
ARM GAS  /tmp/cc3y5xFn.s 			page 4


 128:./Src/main.c  **** static TimerEvent_t TxLedTimer;
 129:./Src/main.c  **** static void OnTimerLedEvent( void );
 130:./Src/main.c  **** #endif
 131:./Src/main.c  **** /* !
 132:./Src/main.c  ****  *Initialises the Lora Parameters
 133:./Src/main.c  ****  */
 134:./Src/main.c  **** static LoRaParam_t LoRaParamInit = {TX_ON_TIMER,
 135:./Src/main.c  ****                                     APP_TX_DUTYCYCLE,
 136:./Src/main.c  ****                                     CLASS_A,
 137:./Src/main.c  ****                                     LORAWAN_ADR_ON,
 138:./Src/main.c  ****                                     DR_0,
 139:./Src/main.c  ****                                     LORAWAN_PUBLIC_NETWORK,
 140:./Src/main.c  ****                                     JOINREQ_NBTRIALS};
 141:./Src/main.c  **** 
 142:./Src/main.c  **** /* Private functions ---------------------------------------------------------*/
 143:./Src/main.c  **** 
 144:./Src/main.c  **** #if 0
 145:./Src/main.c  **** typedef enum {
 146:./Src/main.c  **** 	i2cSpeed_std,
 147:./Src/main.c  **** 	i2cSpeed_fast,
 148:./Src/main.c  **** 	i2cSpeed_fastPlus,
 149:./Src/main.c  **** 	i2cSpeed_count,
 150:./Src/main.c  **** } i2cSpeed_t;
 151:./Src/main.c  **** 
 152:./Src/main.c  **** void i2cInit(I2C_TypeDef *i2c, i2cSpeed_t spd);
 153:./Src/main.c  **** 
 154:./Src/main.c  **** #define I2C_7BIT_ADDR (0 << 31)
 155:./Src/main.c  **** #define I2C_10BIT_ADDR (1 << 31)
 156:./Src/main.c  **** 
 157:./Src/main.c  **** // Returns number of bytes written
 158:./Src/main.c  **** uint32_t i2cWrite(I2C_TypeDef *i2c, uint32_t addr, uint8_t *txBuffer,
 159:./Src/main.c  **** 				  uint32_t len);
 160:./Src/main.c  **** 
 161:./Src/main.c  **** // Returns number of bytes read
 162:./Src/main.c  **** uint32_t i2cRead(I2C_TypeDef *i2c, uint8_t addr, uint8_t *rxBuffer,
 163:./Src/main.c  **** 				 uint32_t numBytes);
 164:./Src/main.c  **** 
 165:./Src/main.c  **** #define I2C_READ 0
 166:./Src/main.c  **** #define I2C_WRITE 1
 167:./Src/main.c  **** 
 168:./Src/main.c  **** static uint32_t setupTiming(i2cSpeed_t spd, uint32_t clockFreq) {
 169:./Src/main.c  **** 	(void) spd;
 170:./Src/main.c  **** 	(void) clockFreq;
 171:./Src/main.c  **** 	uint32_t presc = 0;
 172:./Src/main.c  **** 	uint32_t sdadel = 2;
 173:./Src/main.c  **** 	uint32_t scldel = 2;
 174:./Src/main.c  **** 	uint32_t scll = 6;
 175:./Src/main.c  **** 	uint32_t sclh = 7;
 176:./Src/main.c  **** 
 177:./Src/main.c  **** 	return  presc << 28 |
 178:./Src/main.c  **** 			scldel << 20 |
 179:./Src/main.c  **** 			sdadel << 16 |
 180:./Src/main.c  **** 			sclh << 8 |
 181:./Src/main.c  **** 			scll;
 182:./Src/main.c  **** }
 183:./Src/main.c  **** 
 184:./Src/main.c  **** void i2cInit(I2C_TypeDef *i2c, i2cSpeed_t spd) {
ARM GAS  /tmp/cc3y5xFn.s 			page 5


 185:./Src/main.c  **** 	// Setup timing register
 186:./Src/main.c  **** 	i2c->TIMINGR = setupTiming(spd, SystemCoreClock);
 187:./Src/main.c  **** 
 188:./Src/main.c  **** 	// Reset state
 189:./Src/main.c  **** 	i2c->CR1 &= ~I2C_CR1_PE;
 190:./Src/main.c  **** }
 191:./Src/main.c  **** 
 192:./Src/main.c  **** static uint32_t i2cSetup(uint32_t addr, uint8_t direction) {
 193:./Src/main.c  **** 	uint32_t ret = 0;
 194:./Src/main.c  **** 	if (addr & I2C_10BIT_ADDR) {
 195:./Src/main.c  **** 		ret = (addr & 0x000003FF) | I2C_CR2_ADD10;
 196:./Src/main.c  **** 	} else {
 197:./Src/main.c  **** 		// 7 Bit Address
 198:./Src/main.c  **** 		ret = (addr & 0x0000007F) << 1;
 199:./Src/main.c  **** 	}
 200:./Src/main.c  **** 
 201:./Src/main.c  **** 	if (direction == I2C_READ) {
 202:./Src/main.c  **** 		ret |= I2C_CR2_RD_WRN;
 203:./Src/main.c  **** 		if (addr & I2C_10BIT_ADDR) {
 204:./Src/main.c  **** 			ret |= I2C_CR2_HEAD10R;
 205:./Src/main.c  **** 		}
 206:./Src/main.c  **** 	}
 207:./Src/main.c  **** 
 208:./Src/main.c  **** 	return ret;
 209:./Src/main.c  **** }
 210:./Src/main.c  **** 
 211:./Src/main.c  **** // Will return the number of data bytes written to the device
 212:./Src/main.c  **** uint32_t i2cWrite(I2C_TypeDef *i2c, uint32_t addr, uint8_t *txBuffer,
 213:./Src/main.c  **** 				  uint32_t len) {
 214:./Src/main.c  **** 
 215:./Src/main.c  **** 	uint32_t numTxBytes = 0;
 216:./Src/main.c  **** 
 217:./Src/main.c  **** 	i2c->CR1 &= ~I2C_CR1_PE;
 218:./Src/main.c  **** 	i2c->CR2 = 0;
 219:./Src/main.c  **** 
 220:./Src/main.c  **** 	i2c->CR2 = i2cSetup(addr, I2C_WRITE);
 221:./Src/main.c  **** 
 222:./Src/main.c  **** 	if (len > 0xFF) {
 223:./Src/main.c  **** 		i2c->CR2 |= 0x00FF0000 | I2C_CR2_RELOAD;
 224:./Src/main.c  **** 	} else {
 225:./Src/main.c  **** 		i2c->CR2 |= ((len & 0xFF) << 16) | I2C_CR2_AUTOEND;
 226:./Src/main.c  **** 	}
 227:./Src/main.c  **** 	i2c->CR1 |= I2C_CR1_PE;
 228:./Src/main.c  **** 	i2c->CR2 |= I2C_CR2_START;
 229:./Src/main.c  **** 	while(i2c->CR2 & I2C_CR2_START);
 230:./Src/main.c  **** 	uint8_t done = 0;
 231:./Src/main.c  **** 	uint32_t i = 0;
 232:./Src/main.c  **** 	while (!done && i < 0x0000001F) {
 233:./Src/main.c  **** 		i++;
 234:./Src/main.c  **** 		if (i2c->ISR & I2C_ISR_NACKF) {
 235:./Src/main.c  **** 			// Was not acknowledged, disable device and exit
 236:./Src/main.c  **** 			done = 1;
 237:./Src/main.c  **** 		}
 238:./Src/main.c  **** 
 239:./Src/main.c  **** 		if (i2c->ISR & I2C_ISR_TXIS) {
 240:./Src/main.c  **** 			// Device acknowledged and we must send the next byte
 241:./Src/main.c  **** 			if (numTxBytes < len){
ARM GAS  /tmp/cc3y5xFn.s 			page 6


 242:./Src/main.c  **** 				i2c->TXDR = txBuffer[numTxBytes++];
 243:./Src/main.c  **** 			}
 244:./Src/main.c  **** 
 245:./Src/main.c  **** 			i = 0;
 246:./Src/main.c  **** 
 247:./Src/main.c  **** 		}
 248:./Src/main.c  **** 
 249:./Src/main.c  **** 		if (i2c->ISR & I2C_ISR_TC) {
 250:./Src/main.c  **** 			done = 1;
 251:./Src/main.c  **** 		}
 252:./Src/main.c  **** 
 253:./Src/main.c  **** 		if (i2c->ISR & I2C_ISR_TCR) {
 254:./Src/main.c  **** 			i = 0;
 255:./Src/main.c  **** 			if ((len - numTxBytes) > 0xFF) {
 256:./Src/main.c  **** 				i2c->CR2 |= 0x00FF0000 | I2C_CR2_RELOAD;
 257:./Src/main.c  **** 			} else {
 258:./Src/main.c  **** 				i2c->CR2 &= ~(0x00FF0000 | I2C_CR2_RELOAD);
 259:./Src/main.c  **** 				i2c->CR2 |= ((len - numTxBytes) & 0xFF) << 16 |
 260:./Src/main.c  **** 							I2C_CR2_AUTOEND;
 261:./Src/main.c  **** 			}
 262:./Src/main.c  **** 		}
 263:./Src/main.c  **** 
 264:./Src/main.c  **** 	}
 265:./Src/main.c  **** 	i2c->CR1 &= ~I2C_CR1_PE;
 266:./Src/main.c  **** 	return numTxBytes;
 267:./Src/main.c  **** }
 268:./Src/main.c  **** 
 269:./Src/main.c  **** uint32_t i2cRead(I2C_TypeDef *i2c, uint8_t addr, uint8_t *rxBuffer,
 270:./Src/main.c  **** 				 uint32_t numBytes) {
 271:./Src/main.c  **** 
 272:./Src/main.c  **** 	uint32_t numRxBytes = 0;
 273:./Src/main.c  **** 
 274:./Src/main.c  **** 	i2c->CR1 &= ~I2C_CR1_PE;
 275:./Src/main.c  **** 	i2c->CR2 = 0;
 276:./Src/main.c  **** 
 277:./Src/main.c  **** 	i2c->CR2 = i2cSetup(addr, I2C_READ);
 278:./Src/main.c  **** 
 279:./Src/main.c  **** 	if (numBytes > 0xFF) {
 280:./Src/main.c  **** 		i2c->CR2 |= 0x00FF0000 | I2C_CR2_RELOAD;
 281:./Src/main.c  **** 	} else {
 282:./Src/main.c  **** 		i2c->CR2 |= ((numBytes & 0xFF) << 16) | I2C_CR2_AUTOEND;
 283:./Src/main.c  **** 	}
 284:./Src/main.c  **** 	i2c->CR1 |= I2C_CR1_PE;
 285:./Src/main.c  **** 	i2c->CR2 |= I2C_CR2_START;
 286:./Src/main.c  **** 
 287:./Src/main.c  **** 	while(i2c->CR2 & I2C_CR2_START);
 288:./Src/main.c  **** 	uint8_t done = 0;
 289:./Src/main.c  **** 	uint32_t i = 0;
 290:./Src/main.c  **** 	while (!done && i < 0x0000001F) {
 291:./Src/main.c  **** 		i++;
 292:./Src/main.c  **** 
 293:./Src/main.c  **** 		if (i2c->ISR & I2C_ISR_RXNE) {
 294:./Src/main.c  **** 			// Device acknowledged and we must send the next byte
 295:./Src/main.c  **** 			if (numRxBytes < numBytes){
 296:./Src/main.c  **** 				rxBuffer[numRxBytes++] = i2c->RXDR;
 297:./Src/main.c  **** 			}
 298:./Src/main.c  **** 
ARM GAS  /tmp/cc3y5xFn.s 			page 7


 299:./Src/main.c  **** 			i = 0;
 300:./Src/main.c  **** 		}
 301:./Src/main.c  **** 
 302:./Src/main.c  **** 		if (i2c->ISR & I2C_ISR_TC) {
 303:./Src/main.c  **** 			done = 1;
 304:./Src/main.c  **** 		}
 305:./Src/main.c  **** 
 306:./Src/main.c  **** 		if (i2c->ISR & I2C_ISR_TCR) {
 307:./Src/main.c  **** 			i = 0;
 308:./Src/main.c  **** 			if ((numBytes - numRxBytes) > 0xFF) {
 309:./Src/main.c  **** 				i2c->CR2 |= 0x00FF0000 | I2C_CR2_RELOAD;
 310:./Src/main.c  **** 			} else {
 311:./Src/main.c  **** 				i2c->CR2 &= ~(0x00FF0000 | I2C_CR2_RELOAD);
 312:./Src/main.c  **** 				i2c->CR2 |= ((numBytes - numRxBytes) & 0xFF) << 16 |
 313:./Src/main.c  **** 							I2C_CR2_AUTOEND;
 314:./Src/main.c  **** 			}
 315:./Src/main.c  **** 		}
 316:./Src/main.c  **** 
 317:./Src/main.c  **** 	}
 318:./Src/main.c  **** 	i2c->CR1 &= ~I2C_CR1_PE;
 319:./Src/main.c  **** 	return numRxBytes;
 320:./Src/main.c  **** }
 321:./Src/main.c  **** #endif
 322:./Src/main.c  **** 
 323:./Src/main.c  **** 
 324:./Src/main.c  **** /**
 325:./Src/main.c  ****   * @brief  Main program
 326:./Src/main.c  ****   * @param  None
 327:./Src/main.c  ****   * @retval None
 328:./Src/main.c  ****   */
 329:./Src/main.c  **** int main(void)
 330:./Src/main.c  **** {
  48              		.loc 1 330 0
  49              		.cfi_startproc
  50              		@ Volatile: function does not return.
  51              		@ args = 0, pretend = 0, frame = 32
  52              		@ frame_needed = 0, uses_anonymous_args = 0
  53 0000 10B5     		push	{r4, lr}
  54              	.LCFI0:
  55              		.cfi_def_cfa_offset 8
  56              		.cfi_offset 4, -8
  57              		.cfi_offset 14, -4
  58 0002 88B0     		sub	sp, sp, #32
  59              	.LCFI1:
  60              		.cfi_def_cfa_offset 40
 331:./Src/main.c  **** 	/* STM32 HAL library initialization*/
 332:./Src/main.c  **** 	HAL_Init();
  61              		.loc 1 332 0
  62 0004 FFF7FEFF 		bl	HAL_Init
  63              	.LVL0:
 333:./Src/main.c  **** 
 334:./Src/main.c  **** 	/* Configure the system clock*/
 335:./Src/main.c  **** 	SystemClock_Config();
  64              		.loc 1 335 0
  65 0008 FFF7FEFF 		bl	SystemClock_Config
  66              	.LVL1:
 336:./Src/main.c  **** 
ARM GAS  /tmp/cc3y5xFn.s 			page 8


 337:./Src/main.c  **** 	/* Configure the debug mode*/
 338:./Src/main.c  **** 	DBG_Init();
  67              		.loc 1 338 0
  68 000c FFF7FEFF 		bl	DBG_Init
  69              	.LVL2:
  70              	.LBB2:
 339:./Src/main.c  **** 
 340:./Src/main.c  **** 	__HAL_RCC_GPIOA_CLK_ENABLE();
  71              		.loc 1 340 0
  72 0010 154B     		ldr	r3, .L4
  73 0012 DA6A     		ldr	r2, [r3, #44]
  74 0014 0124     		movs	r4, #1
  75 0016 2243     		orrs	r2, r4
  76 0018 DA62     		str	r2, [r3, #44]
  77 001a DA6A     		ldr	r2, [r3, #44]
  78 001c 2240     		ands	r2, r4
  79 001e 0192     		str	r2, [sp, #4]
  80 0020 019A     		ldr	r2, [sp, #4]
  81              	.LBE2:
  82              	.LBB3:
 341:./Src/main.c  **** 	__HAL_RCC_GPIOC_CLK_ENABLE();
  83              		.loc 1 341 0
  84 0022 D96A     		ldr	r1, [r3, #44]
  85 0024 0422     		movs	r2, #4
  86 0026 1143     		orrs	r1, r2
  87 0028 D962     		str	r1, [r3, #44]
  88 002a DB6A     		ldr	r3, [r3, #44]
  89 002c 1A40     		ands	r2, r3
  90 002e 0292     		str	r2, [sp, #8]
  91 0030 029B     		ldr	r3, [sp, #8]
  92              	.LBE3:
 342:./Src/main.c  **** 
 343:./Src/main.c  **** 	/* Configure the hardware*/
 344:./Src/main.c  **** 	HW_Init();
  93              		.loc 1 344 0
  94 0032 FFF7FEFF 		bl	HW_Init
  95              	.LVL3:
 345:./Src/main.c  **** 	MX_I2C1_Init();
  96              		.loc 1 345 0
  97 0036 FFF7FEFF 		bl	MX_I2C1_Init
  98              	.LVL4:
 346:./Src/main.c  **** 
 347:./Src/main.c  **** 	// BLINKY
 348:./Src/main.c  **** 	GPIO_InitTypeDef initStruct = { 0 };
  99              		.loc 1 348 0
 100 003a 1422     		movs	r2, #20
 101 003c 0021     		movs	r1, #0
 102 003e 03A8     		add	r0, sp, #12
 103 0040 FFF7FEFF 		bl	memset
 104              	.LVL5:
 349:./Src/main.c  **** 	initStruct.Mode =GPIO_MODE_OUTPUT_PP;
 105              		.loc 1 349 0
 106 0044 0494     		str	r4, [sp, #16]
 350:./Src/main.c  **** 	initStruct.Pull = GPIO_NOPULL;
 351:./Src/main.c  **** 	initStruct.Speed = GPIO_SPEED_HIGH;
 107              		.loc 1 351 0
 108 0046 0323     		movs	r3, #3
ARM GAS  /tmp/cc3y5xFn.s 			page 9


 109 0048 0693     		str	r3, [sp, #24]
 352:./Src/main.c  **** 	HW_GPIO_Init(GPIOC, GPIO_PIN_7, &initStruct);
 110              		.loc 1 352 0
 111 004a 03AA     		add	r2, sp, #12
 112 004c 8021     		movs	r1, #128
 113 004e 0748     		ldr	r0, .L4+4
 114 0050 FFF7FEFF 		bl	HW_GPIO_Init
 115              	.LVL6:
 353:./Src/main.c  **** 
 354:./Src/main.c  **** 	/* USER CODE BEGIN 1 */
 355:./Src/main.c  **** 	/* USER CODE END 1 */
 356:./Src/main.c  **** 	voc_init();
 116              		.loc 1 356 0
 117 0054 FFF7FEFF 		bl	voc_init
 118              	.LVL7:
 119              	.L3:
 357:./Src/main.c  **** 
 358:./Src/main.c  **** 	while(1) {
 359:./Src/main.c  **** 		GPIOC->ODR ^= 1<<7;
 120              		.loc 1 359 0 discriminator 1
 121 0058 044A     		ldr	r2, .L4+4
 122 005a 5369     		ldr	r3, [r2, #20]
 123 005c 8021     		movs	r1, #128
 124 005e 4B40     		eors	r3, r1
 125 0060 5361     		str	r3, [r2, #20]
 360:./Src/main.c  **** 		voc_measure();
 126              		.loc 1 360 0 discriminator 1
 127 0062 FFF7FEFF 		bl	voc_measure
 128              	.LVL8:
 129 0066 F7E7     		b	.L3
 130              	.L5:
 131              		.align	2
 132              	.L4:
 133 0068 00100240 		.word	1073876992
 134 006c 00080050 		.word	1342179328
 135              		.cfi_endproc
 136              	.LFE231:
 138              		.text
 139              	.Letext0:
 140              		.file 2 "/usr/arm-none-eabi/include/machine/_default_types.h"
 141              		.file 3 "/usr/arm-none-eabi/include/sys/_stdint.h"
 142              		.file 4 "Drivers/CMSIS/Device/ST/STM32L0xx/Include/system_stm32l0xx.h"
 143              		.file 5 "Drivers/CMSIS/Device/ST/STM32L0xx/Include/stm32l073xx.h"
 144              		.file 6 "Drivers/CMSIS/Device/ST/STM32L0xx/Include/stm32l0xx.h"
 145              		.file 7 "/usr/arm-none-eabi/include/sys/lock.h"
 146              		.file 8 "/usr/arm-none-eabi/include/sys/_types.h"
 147              		.file 9 "/usr/lib/gcc/arm-none-eabi/7.2.0/include/stddef.h"
 148              		.file 10 "/usr/arm-none-eabi/include/sys/reent.h"
 149              		.file 11 "Drivers/STM32L0xx_HAL_Driver/Inc/stm32l0xx_hal_def.h"
 150              		.file 12 "Drivers/STM32L0xx_HAL_Driver/Inc/stm32l0xx_hal_gpio.h"
 151              		.file 13 "Drivers/STM32L0xx_HAL_Driver/Inc/stm32l0xx_hal_dma.h"
 152              		.file 14 "Drivers/STM32L0xx_HAL_Driver/Inc/stm32l0xx_hal_i2c.h"
 153              		.file 15 "Inc/hw_i2c.h"
 154              		.file 16 "/usr/arm-none-eabi/include/math.h"
 155              		.file 17 "Middlewares/Third_Party/Lora/Mac/LoRaMac.h"
 156              		.file 18 "Middlewares/Third_Party/Lora/Core/lora.h"
 157              		.file 19 "./Src/../Drivers/BME680/bme680_defs.h"
ARM GAS  /tmp/cc3y5xFn.s 			page 10


 158              		.file 20 "./Src/voc_sensor.h"
 159              		.file 21 "Drivers/STM32L0xx_HAL_Driver/Inc/stm32l0xx_hal.h"
 160              		.file 22 "Inc/hw_msp.h"
 161              		.file 23 "Inc/debug.h"
 162              		.file 24 "Inc/hw_gpio.h"
 163              		.file 25 "<built-in>"
ARM GAS  /tmp/cc3y5xFn.s 			page 11


DEFINED SYMBOLS
                            *ABS*:0000000000000000 main.c
     /tmp/cc3y5xFn.s:16     .text.HW_GetBatteryLevel:0000000000000000 $t
     /tmp/cc3y5xFn.s:23     .text.HW_GetBatteryLevel:0000000000000000 HW_GetBatteryLevel
     /tmp/cc3y5xFn.s:39     .text.main:0000000000000000 $t
     /tmp/cc3y5xFn.s:46     .text.main:0000000000000000 main
     /tmp/cc3y5xFn.s:133    .text.main:0000000000000068 $d
                     .debug_frame:0000000000000010 $d

UNDEFINED SYMBOLS
HAL_Init
SystemClock_Config
DBG_Init
HW_Init
MX_I2C1_Init
memset
HW_GPIO_Init
voc_init
voc_measure
